# 最佳实践

## 命令行的经验

### 尊重POSIX

使用兼容POSIX-compliant命令行的语法，因为这是被广泛接受的命令行工具的标准。

### 构建友好的CLI

尽可能多的输出一些信息以帮助用户成功使用CLI。

### 有状态的数据

在多次调用CLI的过程中，提供有状态的体验，记住这些数据，以提供无缝的交互体验。

可以使用一下工具来保留用户的这些配置

* configstore
* conf

### 提供多彩的体验

在CLI工具中使用颜色来突出显示一些信息，并且提供降级方案，进行检测，自动退出以免输出乱码。

* chalk
* colors

### 丰富的交互

提供除了文本输入之外的其他交互形式，为用户提供更加丰富的体验。

* prompts
* enquirer
* ink
* ora

### 无处不在的超链接

URL(https://www.github.com)和源代码(src/Util.js:2:75)使用格式正确的文本输出，因为这两者都是现代终端可点击的链接。

### 零配置

通过自动监测所需的配置和命令行参数，达到即开即用的体验

* the jest javascript testing framework
* parcel, a web application bundler

## 发布

### 最小化依赖

最大程度地减少生产环境的依赖项，并且使用可替代的最小的依赖包，确保这是一个尽可能小的Node.js包。但是，也不能过于谨慎因此重复发明轮子而过度优化依赖。

使用npx可以快速调用通过npm install安装的Node.js CLI模块，这可提供更好的用户体验。这有助于将整体的依赖关系和传递依赖关系保持在合理大小。

npm全局安装模块，安装过程会变得缓慢，这是一个糟糕的体验。通过npx总是获取当前项目安装的模块（当前文件夹的node_modules），因为使用npx来调用CLI可能会降低性能。

### 使用文件锁

通过npm提供的package-lock.json来锁定安装包，以确保用户安装的时候使用的依赖版本是准确地。

通常，npm包在发布时只定义其直接的依赖项及其版本范围，并且npm会在安装时解析所有间接依赖的版本。随着时间的流失，间接的依赖项版本会有所不同，因为依赖项随时会发布新版本。

尽管维护人员已广泛使用版本控制语义，但是npm会为安装的包引入许多间接的依赖关系，这些间接依赖提升了破坏您的应用程序的风险。

使用package-lock.json会带给用户更好的安全感。将要安装的依赖项固定到特定版本，因此，即使这些依赖项发布了较新的版本，也不会安装它们。这将让您有责任保持对依赖项的关注，了解依赖项中任何安全相关的修复，并通过定期发布CLI工具进行安全更新。可以考虑使用Synk来自动修复整个依赖性树中的安全性问题、

## 通用性

### 接受STDIN作为输入

对于数据驱动的命令行应用，用户可以轻松的通过管道将数据输入到STDIN

如果命令行工具需要处理某些数据，比如，指定JSON文件执行某种任务，一般使用--file file.json的命令行参数。

### 结构化输出

通过某个参数来允许应用的结果进行结构化的输出，这样使得数据更容易处理和解析。

对于CLI的用户来说，解析数据并使用数据来执行其他任务通常很有用。能够轻松地从命令行输出中得到需要的数据，这将为CLI的用户提供更好的体验。

### 跨平台

如果希望CLI能够跨平台工作，则必须注意命令行shell和子系统（如文件系统）的语义。

单纯从代码的角度来看，功能没有被剥离，并且应该在不同的操作系统中执行良好，但是一些遗漏的细节可能会使程序无法运行。让我们来研究几个必须遵守跨平台规范的案例。

#### 产生错误的命令

有时候我们需要运行Node.js程序的进程，假设您有如下的脚本：

```js
// program.js
#!/usr/bin/env bin

// your app code
```

然后使用如下方式启动

```js
const cliExecPath = 'program.js';
const process = childProcess.spawn(cliExecPath, []);
```

上面的代码能工作，但是下面这样更好

```js
const cliExecPath = 'program.js';
const process = childProcess.spawn('node', [cliExecPath]);
```

为什么这样更好呢？因为program.js代码以类Unix的Shebang符号开始，但是由于这不是跨平台的标准，Windows不知道如何解析。

在package.json中也是如此，如下方式定义npm script是不正确的：

```js
"scripts": {
    "postinstall": "myInstall.js"
}
```

这是因为Windows无法理解myinstall.js中的Shebang，并且不知道如何使用node解释器运行它。

相反，请使用如下方法：

```js
"scrtips": {
    "postinstall": "node myInstall.js"
}
```

#### 不同的shell解释器

并不是所有的字符在不同的shell解释器都能得到相同的处理。

例如，windows的命令提示符不会像bash shell那样将单引号当做双引号，因此它不知道单引号内的所有字符属于同一个字符串组，这会导致错误。

下面的命令会导致在Windows环境下失效：

```js
// package.json
"scripts": {
    "format": "prettier-standard '**/*,js'",
    ... 
}
```

应该按照如下方式：

```js
// package.json
"scripts": {
    "format": "prettier-standard \"**/*.js\"",
    ...
}
```

#### 避免手动连接路径

不同平台会使用不用的路径连接符，当通过手动连接它们时，会导致程序不能在不同的平台之间互相操作。

不好的案例

```js
const myPath = `${__diranme}/../bin/myBin.js`
```

它使用的是正斜杠，但是Windows上是使用反斜杠作为路径的分隔符。所以我们不要通过手动的方式构建文件系统路径，而是使用Node.js的路径模块

```js
const myPath = path.join(__dirname, '..', 'bin', 'myBin.js')
```

#### 避免使用分号链接命令

我们在Linux上一般都使用分号来顺序链接要运行的命令，例如: cd/tmp; ls。但是，在windows上执行相同的操作会失败。

```js
const process = childProcess.exec(`${cliExecPath}; ${cliExecPath2}`)
```

我们可以使用&&或者||

```js
const process = childProcess.exec(`${cliExecPath} || ${cliExecPath2}`)
```

### 允许环境覆盖

允许从环境变量中读取配置，并且当它与命令行参数冲突时，允许环境变量被覆盖。

使用环境变量调整配置，这是许多工具中用于修改CLI工具行为的常用方法。

当命令行参数和环境变量都配置相同的设置时，应该给环境变量一个优先级来覆盖该设置。

## 易用性

### 环境支持

为CLI创建一个docker径向，并将其发布到Docker Hub之类的公共仓库中，以便没有Node.js环境的用户可以使用它。

从npm仓库中下载Node.js CLI工具通常见使用Node.js工具链（例如npm或npx）来完成。这在JavaScript和Node.js开发者中很容易完成。

但是，如果您将CLI程序提供共给大众使用，而不管他们是否熟悉JavaScript或该环境是否可用，那么将闲置CLI程序仅以npm仓库形式的安装分发。如果您的CLI工具打算在CI环境中使用，则可能还需要安装那些与Node.js相关的工具链依赖项。

打包和分发可执行文件的方式有很多，将预先绑定了CLI工具的Docker容易进行容器化，则是一种容易使用方法并且不需要太多依赖关系（除了需要Docker环境之外）。

### 优雅降级

在用户不受支持的环境中提供没有彩色和丰富交互的输出，比如跳过某些交互直接提供JSON格式的输出。

对于那些拥有丰富交互形式的终端的用户来说，彩色输出，ascii图表，终端动画会带来很好的用户体验，但是对于没有这些特性的终端用户来说，它可能会显示一下乱码或者完全无法操作。

要使终端不受支持的用户正确使用您的CLI工具，您有如下选择：

* 自动检测终端能力，并在运行时评估是否对CLI的交互性进行降级
* 为用户提供一个选项来显式地进行降级，例如通过一个--json命令行参数来强制输出原始数据

### Node.js版本兼容

支持目前还在维护的Node.js版本

有时可能需要专门针对缺少新的ECAMScript特性的旧Node.js版本兼容。例如，如果您正在构建一个主要面向DevOps的Node.js CLI，那么他们可能没有一个李翔的Node.js环境或者是最新的runtime。

如果你的需要兼容旧版本的Node.js如Node.js8-6-4，最好是使用Babel之类的编译器来确保生成的代码与V8 JavaScript引擎的版本兼容，并与这些版本附带的Node.js runtime兼容。

绝对不要因此简化你的代码，来使用一些旧的ECMAScript语言规范，因为这会产生代码维护相关的问题。

### 自动监测Node.js runtime

在Shebang声明中使用与安装位置无关的引用，该引用可根据运行时环境自动定位Node.js runtime。

首先在cli.js文件的顶部添加#!/usr/local/bin/node，然后通过node cli.js来启动Node.js CLI，这是一个容易的开始。但是，这是一种有缺陷的方法，因为其他用户的环境无法保证node可执行文件的位置。

我们可以将#!/usr/bin/env node作为最佳实践，但是这仍然假设Node.js runtime是被bin/node引用，而不是bin/nodejs或者其他。

## 测试

### 不要信任语言环境

不要假定输出文本与您声明的字符串等效，因为测试可能在与您的语言环境不同。

当运行CLI并解析输出来测试CLI时，您可能倾向于使用grep命令，以确保某些字符存在于输出中，例如在不带参数的情况下运行CLI时：

```js
const output = execSync(cli);
export(output.to.contain("Examples:"))
```

在非英语的语言环境中运行测试，并且CLI参数解析库支持自动监测语言环境并采用该语言环境，则输出Examples转换成了”语言环境“的语言，测试将失败。

## 错误

### 错误信息

在展示错误信息时，提供可以在项目文档中查找的可跟踪错误的代码，从而简化错误消息的排除。

返回错误信息时，请确保它们包含特定的错误代码，以便以后查询。与HTTP状态代码非常相似，因此CLI工具需要命名或编码错误。

### 可行的错误

错误消息应该告诉用户解决方法是什么，而不是仅仅提示这里存在错误。

### 提供测试模式

如果高级用户需要诊断问题，则给他们提供更详细的信息。

使用环境变量或命令行参数来设置调试模式并打开详细输出信息。在代码中有意义的地方，植入调试消息，以帮助用户和维护者理解程序，输入和输出以及其他使解决问题变得容易的信息。

* debug
